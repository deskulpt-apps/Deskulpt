/*! Auto-generated by xtask-gen. DO NOT EDIT! */

import { invoke } from "@tauri-apps/api/core";
import * as tauriEvent from "@tauri-apps/api/event";

// =============================================================================
// Types
// =============================================================================

/**
 * Deskulpt window enum.
 */
export type DeskulptWindow = 
/**
 * The manager window.
 */
"manager" | 
/**
 * The canvas window.
 */
"canvas"

export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }

/**
 * Cursor for log pagination.
 */
export type LogCursor = { 
/**
 * The rotating log file path.
 */
path: string; 
/**
 * The byte offset within the log file.
 * 
 * If offset is non-zero, there is older data in this file in [0, offset).
 * If offset is zero, this file is fully consumed and the next older
 * non-empty file should be read.
 */
offset: number }

/**
 * A single log entry.
 */
export type LogEntry = { 
/**
 * Timestamp of the log entry in RFC 3339 format.
 */
timestamp: string; 
/**
 * The logging level, all capitals.
 */
level: string; 
/**
 * The log message.
 */
message: string; 
/**
 * The raw JSON representation of the log entry.
 */
raw: JsonValue }

/**
 * A page of log entries.
 */
export type LogPage = { 
/**
 * Log entries in reverse chronological order, i.e., newest first.
 */
entries: LogEntry[]; 
/**
 * Cursor for fetching the next page of older log entries.
 */
cursor: LogCursor | null; 
/**
 * Whether there are more log entries available beyond this page.
 */
hasMore: boolean }

/**
 * Logging levels supported.
 * 
 * They correspond to the [`tracing::Level`] variants.
 */
export type LoggingLevel = "trace" | "debug" | "info" | "warn" | "error"

/**
 * The target to open.
 */
export type OpenTarget = 
/**
 * The widgets base directory.
 */
"widgets" | 
/**
 * A specific widget directory by its ID.
 */
{ widget: string } | 
/**
 * The logs directory.
 */
"logs"

/**
 * Event for showing a toast notification.
 * 
 * This event is emitted from the backend to the canvas window when a toast
 * notification needs to be displayed.
 */
export type ShowToastEvent = 
/**
 * Show a [success](https://sonner.emilkowal.ski/toast#success) toast.
 */
{ type: "success"; content: string } | 
/**
 * Show an [error](https://sonner.emilkowal.ski/toast#error) toast.
 */
{ type: "error"; content: string }

// =============================================================================
// Events
// =============================================================================

function makeEvent<T>(name: string) {
  return {
    /** The name of the event. */
    name,
    /** Listen for the event. */
    listen: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.listen(name, cb, options),
    /** Listen once for the event. */
    once: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.once(name, cb, options),
    /** Emit the event to all targets. */
    emit: (payload: T) => tauriEvent.emit(name, payload),
    /** Emit the event to a specific Deskulpt window. */
    emitTo: (window: DeskulptWindow, payload: T) =>
      tauriEvent.emitTo(window, name, payload),
  };
}

export const events = {
  showToast: makeEvent<ShowToastEvent>("deskulpt-core://show-toast"),
};

// =============================================================================
// Commands
// =============================================================================

export const commands = {
  /**
   * Call a plugin command (ðŸš§ TODO ðŸš§).
   * 
   * ### ðŸš§ TODO ðŸš§
   * 
   * The Deskulpt core should keep a state of the registered plugins and call the
   * plugins dynamically. Also, instead of invoking the plugins directly, the
   * Deskulpt core should not depend on any of the plugins and should use IPC to
   * communicate with the plugins.
   * 
   * Also, in order to simplify the engine API for the plugin (because it is
   * a temporary implementation), `app_handle` is using the default runtime but
   * it should be a generic `R: Runtime` parameter in the final implementation.
   */
  callPlugin: (
    plugin: string,
    command: string,
    id: string,
    payload: JsonValue | null,
  ) => invoke<JsonValue>("plugin:deskulpt-core|call_plugin", {
    plugin,
    command,
    id,
    payload,
  }),

  /**
   * Clear all log files and return the freed disk space in bytes.
   * 
   * ### Errors
   * 
   * - Error discovering log files.
   */
  clearLogs: () => invoke<number>("plugin:deskulpt-core|clear_logs"),

  /**
   * Fetch a page of log entries.
   * 
   * The limit specifies the maximum number of log entries to retrieve and must
   * be strictly positive. The cursor is for pagination. The first call should
   * pass `None` for the cursor to start from the newest log entries, and
   * subsequent calls should use the cursor returned from the previous call to
   * fetch older entries. `min_level` filters log entries to only those at or
   * above the specified logging level (ordered by severity).
   * 
   * ### Errors
   * 
   * - The limit is zero.
   * - Failed to retrieve metadata of log files.
   * - Failed to read log files.
   */
  fetchLogs: (
    limit: number,
    cursor: LogCursor | null,
    minLevel: LoggingLevel,
  ) => invoke<LogPage>("plugin:deskulpt-core|fetch_logs", {
    limit,
    cursor,
    minLevel,
  }),

  /**
   * Log a message at the specified level from the frontend.
   * 
   * Optional metadata can be provided as a JSON value. If no metadata is needed,
   * pass null.
   */
  log: (
    level: LoggingLevel,
    message: string,
    meta: JsonValue,
  ) => invoke<null>("plugin:deskulpt-core|log", {
    level,
    message,
    meta,
  }),

  /**
   * Open a specified target with the system's default application.
   * 
   * See [`OpenTarget`] for more details.
   * 
   * ### Errors
   * 
   * - Error accessing the specified target.
   * - Error opening the target.
   */
  open: (
    target: OpenTarget,
  ) => invoke<null>("plugin:deskulpt-core|open", {
    target,
  }),
};
