//! Deskulpt settings manager and its APIs.

use std::path::PathBuf;
use std::sync::{RwLock, RwLockReadGuard};

use anyhow::{Result, bail};
use deskulpt_common::event::Event;
use tauri::{AppHandle, Manager, Runtime};

use crate::events::UpdateEvent;
use crate::hooks::SettingsHooks;
use crate::settings::{Settings, SettingsPatch, ShortcutKey, Theme};
use crate::worker::{WorkerHandle, WorkerTask};

/// Manager for Deskulpt settings.
pub struct SettingsManager<R: Runtime> {
    /// The Tauri app handle.
    app_handle: AppHandle<R>,
    /// The Deskulpt settings.
    settings: RwLock<Settings>,
    /// The collection of hooks on settings change.
    pub(crate) hooks: RwLock<SettingsHooks>,
    /// The handle for the worker.
    worker: WorkerHandle,
    /// The path where settings are persisted on disk.
    persist_path: PathBuf,
}

impl<R: Runtime> SettingsManager<R> {
    /// Initialize the [`SettingsManager`].
    ///
    /// TODO. A worker is started immediately.
    pub fn new(app_handle: AppHandle<R>) -> Self {
        let persist_path = app_handle
            .path()
            .app_local_data_dir()
            .unwrap()
            .join("settings.json");

        let settings = Settings::load(&persist_path).unwrap_or_else(|e| {
            eprintln!("Failed to load settings: {e:?}");
            Default::default()
        });

        let worker = WorkerHandle::new(app_handle.clone());

        Self {
            app_handle,
            settings: RwLock::new(settings),
            hooks: Default::default(),
            worker,
            persist_path,
        }
    }

    /// Get an immutable reference to the current settings.
    ///
    /// The returned guard will hold a read lock on the settings until dropped.
    /// It is the caller's responsibility to drop the guard as soon as possible
    /// and never attempt to acquire other locks while holding it to avoid
    /// deadlocks.
    pub fn read(&self) -> RwLockReadGuard<'_, Settings> {
        self.settings.read().unwrap()
    }

    /// Register a hook that will be triggered on theme change.
    ///
    /// The two arguments are respectively the old and new themes.
    pub fn on_theme_change<F>(&self, hook: F)
    where
        F: Fn(&Theme, &Theme) + Send + Sync + 'static,
    {
        let mut hooks = self.hooks.write().unwrap();
        hooks.on_theme_change.push(Box::new(hook));
    }

    /// Register a hook that will be triggered on shortcut change.
    ///
    /// The first argument is the shortcut key. The second and third arguments
    /// are respectively the old and new shortcuts. `None` means that no
    /// shortcut was/is assigned for that key.
    pub fn on_shortcut_change<F>(&self, hook: F)
    where
        F: Fn(&ShortcutKey, Option<&String>, Option<&String>) + Send + Sync + 'static,
    {
        let mut hooks = self.hooks.write().unwrap();
        hooks.on_shortcut_change.push(Box::new(hook));
    }

    /// Update the settings with a patch.
    ///
    /// This is a wrapper of [`Self::update_with`] that takes a fixed patch.
    ///
    /// Tauri command: [`crate::commands::update`].
    pub fn update(&self, patch: SettingsPatch) -> Result<()> {
        self.update_with(|_| patch)
    }

    /// Update the settings with a patch generated by a closure.
    ///
    /// TODO
    pub fn update_with<F>(&self, patch: F) -> Result<()>
    where
        F: FnOnce(&Settings) -> SettingsPatch,
    {
        let mut settings = self.settings.write().unwrap();
        let patch = patch(&settings);

        let mut tasks = vec![];
        let mut dirty = false;

        if let Some(theme) = patch.theme
            && settings.theme != theme
        {
            let old_theme = std::mem::replace(&mut settings.theme, theme.clone());
            tasks.push(WorkerTask::Theme {
                old: old_theme,
                new: theme,
            });
            dirty = true;
        }

        if let Some(shortcuts) = patch.shortcuts {
            for (key, shortcut) in shortcuts {
                let old_shortcut = match &shortcut {
                    Some(shortcut) => settings.shortcuts.insert(key.clone(), shortcut.clone()),
                    None => settings.shortcuts.remove(&key),
                };
                if old_shortcut != shortcut {
                    tasks.push(WorkerTask::Shortcut {
                        key,
                        old: old_shortcut,
                        new: shortcut,
                    });
                    dirty = true;
                }
            }
        }

        if let Some(widgets) = patch.widgets {
            for (id, patch) in widgets {
                match patch {
                    Some(patch) => {
                        let widget = settings.widgets.entry(id).or_insert_with(|| {
                            dirty = true;
                            Default::default()
                        });
                        dirty |= widget.apply_patch(patch);
                    },
                    None => dirty |= settings.widgets.remove(&id).is_some(),
                }
            }
        }

        if dirty {
            UpdateEvent(&settings).emit(&self.app_handle)?;
        }

        let mut errors = vec![];
        for task in tasks {
            if let Err(e) = self.worker.process(task) {
                errors.push(e);
            }
        }
        if !errors.is_empty() {
            let message = errors
                .into_iter()
                .map(|e| format!("{e:?}"))
                .collect::<Vec<_>>()
                .join("\n\n");
            bail!("One or more changes failed to be submitted\n\n{message}");
        }

        Ok(())
    }

    pub fn persist(&self) -> Result<()> {
        let settings = self.settings.read().unwrap();
        settings.dump(&self.persist_path)?;
        Ok(())
    }
}
