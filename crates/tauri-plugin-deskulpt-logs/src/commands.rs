//! Tauri commands.
#![doc = include_str!("../permissions/autogenerated/reference.md")]

use deskulpt_common::SerResult;
use serde::Deserialize;
use tauri::{AppHandle, Runtime, WebviewWindow};

use crate::LogsExt;
use crate::reader::{Cursor, Page};

/// Level of severity for logging.
#[derive(Debug, Deserialize, specta::Type)]
#[serde(rename_all = "camelCase")]
pub enum Level {
    /// At least the severity of [`tracing::Level::TRACE`].
    Trace,
    /// At least the severity of [`tracing::Level::DEBUG`].
    Debug,
    /// At least the severity of [`tracing::Level::INFO`].
    Info,
    /// At least the severity of [`tracing::Level::WARN`].
    Warn,
    /// At least the severity of [`tracing::Level::ERROR`].
    Error,
}

impl From<Level> for tracing::Level {
    fn from(level: Level) -> Self {
        match level {
            Level::Trace => tracing::Level::TRACE,
            Level::Debug => tracing::Level::DEBUG,
            Level::Info => tracing::Level::INFO,
            Level::Warn => tracing::Level::WARN,
            Level::Error => tracing::Level::ERROR,
        }
    }
}

/// Emit a log message at the specified level.
///
/// This command allows the frontend to send log messages to the backend's
/// logging system, tagged by the window label they originate from.
///
/// The `meta` parameter accepts any JSON-serializable value to include extra
/// metadata along with the log message. Pass `null` if no metadata is needed.
#[tauri::command]
#[specta::specta]
pub async fn log<R: Runtime>(
    window: WebviewWindow<R>,
    level: Level,
    message: String,
    meta: serde_json::Value,
) -> SerResult<()> {
    match window.label() {
        "canvas" => match level {
            Level::Trace => tracing::trace!(target: "frontend::canvas", %meta, message),
            Level::Debug => tracing::debug!(target: "frontend::canvas", %meta, message),
            Level::Info => tracing::info!(target: "frontend::canvas", %meta, message),
            Level::Warn => tracing::warn!(target: "frontend::canvas", %meta, message),
            Level::Error => tracing::error!(target: "frontend::canvas", %meta, message),
        },
        "portal" => match level {
            Level::Trace => tracing::trace!(target: "frontend::portal", %meta, message),
            Level::Debug => tracing::debug!(target: "frontend::portal", %meta, message),
            Level::Info => tracing::info!(target: "frontend::portal", %meta, message),
            Level::Warn => tracing::warn!(target: "frontend::portal", %meta, message),
            Level::Error => tracing::error!(target: "frontend::portal", %meta, message),
        },
        _ => {},
    }
    Ok(())
}

/// Read a page of log entries.
///
/// This retrieves log entries from the log files, from newest to oldest. At
/// most `limit` log entries will be returned. Only log entries with at least
/// the severity of `min_level` will be included.
///
/// An optional `cursor` can be provided. Pass `null` to start from the latest
/// log entry. Pass a cursor returned from a previous call to continue reading
/// from where you left off. An invalid cursor will be ignored.
#[tauri::command]
#[specta::specta]
pub async fn read<R: Runtime>(
    app_handle: AppHandle<R>,
    limit: usize,
    min_level: Level,
    cursor: Option<Cursor>,
) -> SerResult<Page> {
    let page = app_handle.logs().read(limit, min_level.into(), cursor)?;
    Ok(page)
}

/// Clear all log files.
///
/// This returns the amount of freed space in bytes.
#[tauri::command]
#[specta::specta]
pub async fn clear<R: Runtime>(app_handle: AppHandle<R>) -> SerResult<u64> {
    let size = app_handle.logs().clear()?;
    Ok(size)
}
