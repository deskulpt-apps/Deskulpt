#![doc = include_str!("../README.md")]
#![doc(
    html_logo_url = "https://github.com/deskulpt-apps/Deskulpt/raw/main/public/deskulpt.svg",
    html_favicon_url = "https://github.com/deskulpt-apps/Deskulpt/raw/main/public/deskulpt.svg"
)]

use std::path::PathBuf;

use anyhow::{Result, anyhow, bail};
use quote::{format_ident, quote};

/// Builder for build-time configuration of Deskulpt.
#[derive(Default)]
pub struct Builder {
    commands: &'static [&'static str],
    events: &'static [&'static str],
}

impl Builder {
    /// Set the commands for the builder.
    ///
    /// These will be used for configuring the bindings builder and the Tauri
    /// plugin builder, and for generating plugin initialization code. The
    /// commands must be made public under `crate::commands`.
    pub fn commands(&mut self, commands: &'static [&'static str]) -> &mut Self {
        self.commands = commands;
        self
    }

    /// Set the events for the builder.
    ///
    /// These will be used for configuring the bindings builder. The events must
    /// be made public under `crate::events`.
    pub fn events(&mut self, events: &'static [&'static str]) -> &mut Self {
        self.events = events;
        self
    }

    /// Run the build process, returning an error if it fails.
    pub fn try_build(&self) -> Result<()> {
        let name = env!("CARGO_PKG_NAME");
        if !name.starts_with("deskulpt-") {
            bail!("Plugin crate names must start with 'deskulpt-'; got '{name}'");
        }

        let commands = self
            .commands
            .iter()
            .map(|c| format_ident!("{c}"))
            .collect::<Vec<_>>();
        let events = self
            .events
            .iter()
            .map(|e| format_ident!("{e}"))
            .collect::<Vec<_>>();

        let build_bindings = quote! {
            #[doc(hidden)]
            pub fn build_bindings() -> ::deskulpt_common::bindings::Bindings {
                ::deskulpt_common::bindings::BindingsBuilder::new(env!("CARGO_PKG_NAME"))
                    .commands(::deskulpt_common::bindings::collect_commands![
                        #( crate::commands::#commands::<::tauri::Wry> ),*
                    ])
                    #( .event::<crate::events::#events>() )*
                    .typ::<::deskulpt_common::window::DeskulptWindow>()
                    .build()
            }
        };

        let init_builder = quote! {
            ::tauri::plugin::Builder::new(env!("CARGO_PKG_NAME"))
                .invoke_handler(::tauri::generate_handler![
                    #( crate::commands::#commands ),*
                ])
        };

        let out_dir = std::env::var("OUT_DIR").map_err(|_| anyhow!("OUT_DIR not set"))?;
        let out_dir = PathBuf::from(out_dir);

        std::fs::write(
            out_dir.join("build_bindings.rs"),
            build_bindings.to_string(),
        )?;

        std::fs::write(out_dir.join("init_builder.rs"), init_builder.to_string())?;

        // TODO: Remove when the following issue is fixed:
        // https://github.com/tauri-apps/tauri/issues/14320
        //
        // Temporary workaround to remove the entire autogenerated permissions
        // directory to avoid stale permission files causing wrong capabilities
        // schema to be generated
        let permissions_dir = PathBuf::from("permissions").join("autogenerated");
        if permissions_dir.is_dir() {
            std::fs::remove_dir_all(permissions_dir)?;
        }

        tauri_plugin::Builder::new(self.commands).try_build()?;
        Ok(())
    }

    /// Same as [`Self::try_build`], but exits automatically on error.
    pub fn build(&self) {
        if let Err(error) = self.try_build() {
            println!("{}: {error:?}", env!("CARGO_PKG_NAME"));
            std::process::exit(1);
        }
    }
}
